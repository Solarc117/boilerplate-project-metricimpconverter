<------ Problem Solving Steps from Fireship --------->

1. Identify 
  - definte the issue
  - definte the context
  - why do we care to solve it?
2. Research & Define 
  - Google the problem; you're likely not the first one
  - Discuss w/other devs
  - Break problem down into smaller tasks
  - Determine what tools & apis to use 
3. Pseudo-code
  - how do we implement our code?
  - don't worry about syntax
  - can write pseudo-code in a lang, if you're comfortable enough w/it
4. (optional) Test-Driven Development
  - Consider using Jest (a JS testing library)
  - Red, green, refactor process:
    a) write failing tests that describe what you're trying to do
    b) write code that makes your tests pass
    c) refactor/optimize tests/code
  - good specs help you catch issues much quicker than you could debug them
5. Implement Code
  - try to implement the first working prototype as quickly as possible: try to treat it like a hackathon & don't worry about the quality of the code
    * refactoring and cleaning imperfect code is easier than writing clean code from the get-go
6. Relax, sleep, & reflect on the code
  - take a break if you're stuck!
  - a few suggestions to improve code:
    a) improve readability
    b) add useful comments
    c) remove duplication
    d) optimize time/space complexities
    e) add error handling
    f) add caching
7. Keep practicing! Get feedback from other devs.

<!-------------------- END ------------------------->

📄 I should consider adding messages to assertions (ex. assert.strictEquals(var, expect, MESSAGE)) if it improves readability and is worth the time investment.
📄 I think, ultimately, what will matter more in terms of getting me a dev job will be what I have to show in terms of projects; not so much my fCC certifications. 
📄 render works with templates, like pug. The sendFile method sends file as is.
📄 I might want to read into client.close(); I don't remember that method from my mdbu courses.
📄 difference between req.body, req.query, and req.params:
  📄 req.body is what usually contains the majority of information relevant to the request
  📄 query contains the '...?KEY=VALUE' pairs of a path
  📄 params contain sections of the url that are mapped to certain variables, e.g. 'api/issues/:owner', req.param would contain a variable "owner" with the value pertaining to the string that was in the respective url position at the time of the request. 
📄 be wary of spaghetti code; functions that call other functions in a disorderly manner. Won't worry about it now, but just be wary.

✨ ways to optimize learning that I should remember:
  - take short, mind-wandering breaks apart from ultradian breaks
  - use bedtime to estimate ultradian breaks for the day
  - angle screen upward to trigger alertness
  - consciously try to blink less
  - do productive breaks during ultradian breaks (raise adrenalin, then: NSDR, walk, talk to someone, etc.)
  - implement perceptible, non-intrusive white noise during learning
  - MINIMIZE DISTRACTIONS
  - do not write maintainable, clean code until the first working prototype is done; similar to writing, it is much easier to clean up dirty code than it is to write clean code from the get-go.

-------------- August 5 (YESTERDAY) ------------------

- ✅⚒️ Red, green, refactor: all of the functional tests in tests/issue-tracker.test.js:
  - 🎉⚒️ (1) Update one field on an issue: PATCH request to /api/issues/{project}
    - ✅ figure out how the data will be sent to the handler method
      📄 for the issue text, I might have to use string literals to conserve new lines
    - ✅ address the checkbox's weird behaviour (is undefined or on - turn into a boolean)
    - ✅ create a test that submits a POST request with the project name, and the index of the issue to update, as well as a single field to update. Expect a status of 200, an ok value of true, and for the body to be an object with at least one key value pair. 
    - ✅ log the req.body in the api patch callback
    - ✅ create in issueHandler patch method
    - ✅ link the issuehandler patch method to the api router
    - ✅ create a DAO update method
    - ✅ call the DAO update method in the handler
    - ✅ iterate through the fieldsToUpdate parameter. For each field to update:
    - ✅ find a way to communicate the project name, and issue index, from the issueIndexForm to the updateForm, once the latter is submitted
    - ✅ I have access to the fields to update now; just gotta get access to the index of the issue. Figure out how
    - ✅ on submit, create a patch request with:
      - ✅ the issue index 
      - ✅ the fields to be updated    
    - ✅ verify the patch request does not contain un-modifiable fields
      📄 index, created_by, created_on, or last_updated
    - ✅ edit the test to ensure the exact property was updated to the exact new value, or at least ensure "acknowledged" and "updated_count": 1 are returned
  - ✅ (0) commit & push

--------------- August 6 (YESTERDAY) ------------------

- ✅⚒️ Red, green, refactor: all of the functional tests in tests/issue-tracker.test.js:
  - ✅ ⚒️ (0.5) Update multiple fields on an issue: PATCH request to /api/issues/{project}
  - ✅ (0) commit & push
  - ✅ Update an issue with no fields to update: PATCH request to /api/issues/{project}
  - ✅ commit & push
  - ✅ export test documents, and import them into the required test file - have ONLY tests in the test file.
  - ✅ commit & push
  - ✅⚒️ (0.5) (HALFWAY) Delete an issue: DELETE request to /api/issues/{project}
    - ✅ create a test 
    - ✅ create a handler delete method
    - ✅ create a dao delete method
    - ✅ link up the methdods to the api
    - ✅ fix test 11 & 12 (should be attempting a patch/delete on an EXISTING document, but TEST_DOC_8 was never posted to the database)
    - ✅⚒️ code the DAO delete method
      - ✅ reset the rest of the issue indexes in the current project
        📄 I will use an update (or aggregation) to fetch ALL issues whose index is GREATER than the index passed, and set their indexes to their current value + 1
        📄 Ideally, the delete action would ONLY execute if I was able to update the rest of the indexes, because if only one or the other operation executes, I'll end up with a bug-prone database structure with certain index values skipped

------------------ August 7(TODAY) ------------------- 

- ✅⚒️ Red, green, refactor: all of the functional tests in tests/issue-tracker.test.js:
  - ✅ (COMPLETE) Delete an issue: DELETE request to /api/issues/{project}
  -  commit & push
- ✅ (0.5) verify that DAO errors are SERVER errors: all client errors (bad requests) should be handled in the handler.
- ✅ (0.5) add navbar to issue-tracker
- ✅ (0.5) move script tags out of body tags
- ✅ commit & push

---------------------- August 8 -------------------

- (1) remove tests directory from production; they are for development, after all
- commit & push
- (1) reset all index values in the deleted issue's parent array, instead of the current indexEdit update
- commit & push

------------------------ August 9 (DEADLINE) ------------------------

- (1) review all method documentation
- commit & push
- (0.5) style issue-tracker's index page
- commit & push
- (0.5) verify all issues posted have created_on and last_updated properties
- commit & push
- verify heroku local works; debug if it doesn't
- commit & push any changes from the fix above
- merge dev with main; ensure heroku site deployed & works fine
