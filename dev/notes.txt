<------ Problem Solving Steps from Fireship --------->

1. Identify 
  - definte the issue
  - definte the context
  - why do we care to solve it?
2. Research & Define 
  - Google the problem; you're likely not the first one
  - Discuss w/other devs
  - Break problem down into smaller tasks
  - Determine what tools & apis to use 
3. Pseudo-code
  - how do we implement our code?
  - don't worry about syntax
  - can write pseudo-code in a lang, if you're comfortable enough w/it
4. (optional) Test-Driven Development
  - Consider using Jest (a JS testing library)
  - Red, green, refactor process:
    a) write failing tests that describe what you're trying to do
    b) write code that makes your tests pass
    c) refactor/optimize tests/code
  - good specs help you catch issues much quicker than you could debug them
5. Implement Code
  - try to implement the first working prototype as quickly as possible: try to treat it like a hackathon & don't worry about the quality of the code
    * refactoring and cleaning imperfect code is easier than writing clean code from the get-go
6. Relax, sleep, & reflect on the code
  - take a break if you're stuck!
  - a few suggestions to improve code:
    a) improve readability
    b) add useful comments
    c) remove duplication
    d) optimize time/space complexities
    e) add error handling
    f) add caching
7. Keep practicing! Get feedback from other devs.

<!-------------------- END ------------------------->

ğŸ“„ I should consider adding messages to assertions (ex. assert.strictEquals(var, expect, MESSAGE)) if it improves readability and is worth the time investment.
ğŸ“„ I think, ultimately, what will matter more in terms of getting me a dev job will be what I have to show in terms of projects; not so much my fCC certifications. 
ğŸ“„ render works with templates, like pug. The sendFile method sends file as is.
ğŸ“„ I might want to read into client.close(); I don't remember that method from my mdbu courses.
ğŸ“„ difference between req.body, req.query, and req.params:
  ğŸ“„ req.body is what usually contains the majority of information relevant to the request
  ğŸ“„ query contains the '...?KEY=VALUE' pairs of a path
  ğŸ“„ params contain sections of the url that are mapped to certain variables, e.g. 'api/issues/:owner', req.param would contain a variable "owner" with the value pertaining to the string that was in the respective url position at the time of the request. 
ğŸ“„ be wary of spaghetti code; functions that call other functions in a disorderly manner. Won't worry about it now, but just be wary.

âœ¨ ways to optimize learning that I should remember:
  - take short, mind-wandering breaks apart from ultradian breaks
  - use bedtime to estimate ultradian breaks for the day
  - angle screen upward to trigger alertness
  - consciously try to blink less
  - do productive breaks during ultradian breaks (raise adrenalin, then: NSDR, walk, talk to someone, etc.)
  - implement perceptible, non-intrusive white noise during learning
  - MINIMIZE DISTRACTIONS
  - do not write maintainable, clean code until the first working prototype is done; similar to writing, it is much easier to clean up dirty code than it is to write clean code from the get-go.

-------------- August 5 (YESTERDAY) ------------------

- âœ…âš’ï¸ Red, green, refactor: all of the functional tests in tests/issue-tracker.test.js:
  - ğŸ‰âš’ï¸ (1) Update one field on an issue: PATCH request to /api/issues/{project}
    - âœ… figure out how the data will be sent to the handler method
      ğŸ“„ for the issue text, I might have to use string literals to conserve new lines
    - âœ… address the checkbox's weird behaviour (is undefined or on - turn into a boolean)
    - âœ… create a test that submits a POST request with the project name, and the index of the issue to update, as well as a single field to update. Expect a status of 200, an ok value of true, and for the body to be an object with at least one key value pair. 
    - âœ… log the req.body in the api patch callback
    - âœ… create in issueHandler patch method
    - âœ… link the issuehandler patch method to the api router
    - âœ… create a DAO update method
    - âœ… call the DAO update method in the handler
    - âœ… iterate through the fieldsToUpdate parameter. For each field to update:
    - âœ… find a way to communicate the project name, and issue index, from the issueIndexForm to the updateForm, once the latter is submitted
    - âœ… I have access to the fields to update now; just gotta get access to the index of the issue. Figure out how
    - âœ… on submit, create a patch request with:
      - âœ… the issue index 
      - âœ… the fields to be updated    
    - âœ… verify the patch request does not contain un-modifiable fields
      ğŸ“„ index, created_by, created_on, or last_updated
    - âœ… edit the test to ensure the exact property was updated to the exact new value, or at least ensure "acknowledged" and "updated_count": 1 are returned
  - âœ… (0) commit & push

--------------- August 6 (YESTERDAY) ------------------

- âœ…âš’ï¸ Red, green, refactor: all of the functional tests in tests/issue-tracker.test.js:
  - âœ… âš’ï¸ (0.5) Update multiple fields on an issue: PATCH request to /api/issues/{project}
  - âœ… (0) commit & push
  - âœ… Update an issue with no fields to update: PATCH request to /api/issues/{project}
  - âœ… commit & push
  - âœ… export test documents, and import them into the required test file - have ONLY tests in the test file.
  - âœ… commit & push
  - âœ…âš’ï¸ (0.5) (HALFWAY) Delete an issue: DELETE request to /api/issues/{project}
    - âœ… create a test 
    - âœ… create a handler delete method
    - âœ… create a dao delete method
    - âœ… link up the methdods to the api
    - âœ… fix test 11 & 12 (should be attempting a patch/delete on an EXISTING document, but TEST_DOC_8 was never posted to the database)
    - âœ…âš’ï¸ code the DAO delete method
      - âœ… reset the rest of the issue indexes in the current project
        ğŸ“„ I will use an update (or aggregation) to fetch ALL issues whose index is GREATER than the index passed, and set their indexes to their current value + 1
        ğŸ“„ Ideally, the delete action would ONLY execute if I was able to update the rest of the indexes, because if only one or the other operation executes, I'll end up with a bug-prone database structure with certain index values skipped

------------------ August 7(TODAY) ------------------- 

- âœ…âš’ï¸ Red, green, refactor: all of the functional tests in tests/issue-tracker.test.js:
  - âœ… (COMPLETE) Delete an issue: DELETE request to /api/issues/{project}
  -  commit & push
- âœ… (0.5) verify that DAO errors are SERVER errors: all client errors (bad requests) should be handled in the handler.
- âœ… (0.5) add navbar to issue-tracker
- âœ… (0.5) move script tags out of body tags
- âœ… commit & push

---------------------- August 8 -------------------

- (1) remove tests directory from production; they are for development, after all
- commit & push
- (1) reset all index values in the deleted issue's parent array, instead of the current indexEdit update
- commit & push

------------------------ August 9 (DEADLINE) ------------------------

- (1) review all method documentation
- commit & push
- (0.5) style issue-tracker's index page
- commit & push
- (0.5) verify all issues posted have created_on and last_updated properties
- commit & push
- verify heroku local works; debug if it doesn't
- commit & push any changes from the fix above
- merge dev with main; ensure heroku site deployed & works fine
