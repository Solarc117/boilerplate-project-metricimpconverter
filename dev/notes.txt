<------ Problem Solving Steps from Fireship --------->

1. Identify 
  - definte the issue
  - definte the context
  - why do we care to solve it?
2. Research & Define 
  - Google the problem; you're likely not the first one
  - Discuss w/other devs
  - Break problem down into smaller tasks
  - Determine what tools & apis to use 
3. Pseudo-code
  - how do we implement our code?
  - don't worry about syntax
  - can write pseudo-code in a lang, if you're comfortable enough w/it
4. (optional) Test-Driven Development
  - Consider using Jest (a JS testing library)
  - Red, green, refactor process:
    a) write failing tests that describe what you're trying to do
    b) write code that makes your tests pass
    c) refactor/optimize tests/code
  - good specs help you catch issues much quicker than you could debug them
5. Implement Code
  - try to implement the first working prototype as quickly as possible: try to treat it like a hackathon & don't worry about the quality of the code
    * refactoring and cleaning imperfect code is easier than writing clean code from the get-go
6. Relax, sleep, & reflect on the code
  - take a break if you're stuck!
  - a few suggestions to improve code:
    a) improve readability
    b) add useful comments
    c) remove duplication
    d) optimize time/space complexities
    e) add error handling
    f) add caching
7. Keep practicing! Get feedback from other devs.

<!-------------------- END ------------------------->


ğŸ“„ I should consider adding messages to assertions (ex. assert.strictEquals(var, expect, MESSAGE)) if it improves readability and is worth the time investment.
ğŸ“„ I think, ultimately, what will matter more in terms of getting me a dev job will be what I have to show in terms of projects; not so much my fCC certifications. 
ğŸ“„ render works with templates, like pug. The sendFile method sends file as is.
ğŸ“„ should consider looking up what my brother said about views being automatic, & why it doesn't work on this project.
ğŸ“„ I might want to read into client.close(); I don't remember that method from my mdbu courses.
ğŸ“„ do I need to drop the collection? Or would it be simpler to send a put request for every document that I will need (e.g. if there are two DELETE tests, I can send two PUT requests for every DELETE test)? I think the second will be easier.

âœ¨ ways to optimize learning that I should remember:
  - take short, mind-wandering breaks apart from ultradian breaks
  - use bedtime to estimate ultradian breaks for the day
  - angle screen upward to trigger alertness
  - consciously try to blink less
  - do productive breaks during ultradian breaks (raise adrenalin, then: NSDR, walk, talk to someone, etc.)
  - implement perceptible, non-intrusive white noise during learning
  - MINIMIZE DISTRACTIONS
  - do not write maintainable, clean code until the first working prototype is done; similar to writing, it is much easier to clean up dirty code than it is to write clean code from the get-go.

- âœ… what is the difference between req.body, req.query, and req.params?
  ğŸ“„ req.body is what usually contains the majority of information relevant to the request
  ğŸ“„ query contains the '...?KEY=VALUE' pairs of a path
  ğŸ“„ params contain sections of the url that are mapped to certain variables, e.g. 'api/issues/:owner', req.param would contain a variable "owner" with the value pertaining to the string that was in the respective url position at the time of the request. 

- âš’ï¸ğŸ‰ Red, green, refactor; all of the functional tests in tests/issue-tracker.test.js:
  - âœ… Create an issue with every field: POST request to /api/issues/:project
  - âœ… commit & push
  - âœ… Create an issue with only required fields: POST request to /api/issues/{project}
    - âœ… Fill in null for any optional fields that are not filled in, and respond with a status of 400 (bad req) and a corresponding message if any required fields are not their respective types.
  - âœ… commit & push
  - âœ… Create an issue with missing required fields: POST request to /api/issues/{project}
  - âœ… commit & push
  - âœ… View issues on a project: GET request to /api/issues/{project}
    - âœ… modify GET handler to only return the issues array
  - âœ… commit & push
  - âœ… View issues on a project with one filter: GET request to /api/issues/{project}
    ğŸ“„ pseudocode for filtering db response issues:
      - if response is NOT null âœ…, and issueQueries has at LEAST one key âœ…, and the response has an issues property of type array âœ…:
        - iterate through each issue in the issues array âœ…. For each issue:
          - map through the keys of issueQueries, ensuring the respective key in the current issue matches the value of the same key in the issueQueries parameter âœ…
        - return the response âœ…
  - âœ… commit & push
  - âœ… edit handler get method to NOT nullify null strings, or to only nullify EMPTY strings
    ğŸ“„ instead, empty strings will be nullified, and 'null' strings will literally search for null in strings.
  - âœ… View issues on a project with multiple filters: GET /api/issues/{project}
    ğŸ“„ I'm nullifying empty strings, so as long as a value is a string and not null, the DAO should check that the document CONTAINS - doesn't match exactly, but rather CONTAINS - the query string (case insensitive).
    ğŸ“„ New DAO filterIssues pseudocode:
      ğŸ“„ filterIssues is being passed the issues, and an object of queries to filter the issues with (each value thereof being of type string, OR null). The issues are objects in an array.
      ğŸ“„ If a query is null, filterIssues should only keep issues whose respective property is ALSO null. Aka, it should remove all issues whose respective property is NOT null.
      ğŸ“„ If a query is not null (aka a string), fitlerIssues should only keep issues that contain said string in the respective property. Aka, it should remove issues that do NOT include the query string.
      1. Iterate through a COPY of the issues array, using the Array.filter method. For each issue:
        a) Iterate through the keys of the query object. For each key (and value):
          i) IF the current query value is NULL, return false (filter out the current issue) if the respective value of the issue is NOT also NULL.
          ii) IF the current query value is a STRING, return false (filter out the current  issue) if the respective value of the current issue does NOT include the query string. Do NOT check for exact equality (=== or !==).
      . Return the filtered copy of the issues array. 
  - âœ… commit & push
  - âœ… Automatically add a date property to each new issue
    âœ… Add a date instance in every new document in the DAO
    âœ… pass currently failing test
    ğŸ“„ I will add UTC date strings to the db, and if I need date functionality, I will convert those strings back into date instances.
  - âœ… commit & push
  - âœ… check if a new post request generates a document with an ObjectId, or if not, how we can configure the db to handle that itself. If not, I can add the property automatically.
  - âœ… fix failing tests
  - ğŸ‰ finish fixing _id functionality on the api
  - Update one field on an issue: PATCH request to /api/issues/{project}
    ğŸ“„ Before updating an issue, I need to know WHICH issue to update. 
      One way to do this is to reformat my db to store only SINGLE issues, in collections that pertain to different projects.
      âŒ Another way could be to simply send an object containing query fields to filter out the issue to be updated, as well as another object containing the field(s) and value(s) to be updated.
      âœ¨ Another way could be to give each issue in a project's array its own _id - maybe add a date property to each issue, and organize them chronologically? Or simply add an index to each?

    ğŸ“„ I'll send an object with the _id to update, and whatever fields are to be updated.
  - commit & push
  - Update multiple fields on an issue: PATCH request to /api/issues/{project}
  - commit & push
  - Update an issue with missing _id: PATCH request to /api/issues/{project}
  - commit & push
  - Update an issue with no fields to update: PATCH request to /api/issues/{project}
  - commit & push
  - Update an issue with an invalid _id: PATCH request to /api/issues/{project}
  - commit & push
  - Delete an issue: DELETE request to /api/issues/{project}
  - commit & push
  - Delete an issue with an invalid _id: DELETE request to /api/issues/{project}
  - commit & push
  - Delete an issue with missing _id: DELETE request to /api/issues/{project}

- âš’ï¸ Complete the necessary routes in /routes/api.js for the /api/issues/{project}?open=true&assigned_to=Joe route:
  - get an issue, with the option to filter using asignees, reactions, or other things
  - post
  - PATCH
  - delete 

- should putProject really do an upsert? Or simply a post call?
- check if _id should be a required, or optional property of Project objects.
- ensure method documentation return types are consistent with the actual return types
- style issue-tracker's index page
- add navbar to issue-tracker
- compare fccTestingRoutes
